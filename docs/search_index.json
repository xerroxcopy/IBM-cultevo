[["ライブラリの読み込み.html", "Chapter 1 ライブラリの読み込み", " Chapter 1 ライブラリの読み込み まずは必要となるライブラリをまとめて読み込む。1RStudio上でこの.Rmdファイルを開いている場合、cmd+enter(windowsならctrl+enter)で一行ずつ、cmd+shift+enter(windowsならctrl+shift+enter)でチャンクを一気に実行できる。 library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.1.2 ✓ dplyr 1.0.6 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() 原著では必要になったタイミングでライブラリを読み込んでいるが、Tidyverse style guideにあるように（“If your script uses add-on packages, load them all at once at the very beginning of the file. This is more transparent than sprinkling library() calls throughout your code,” Tidyverse style guide）ライブラリはファイルの冒頭で読み込んでしまうのがベストプラクティスとされている。↩︎ "],["バイアスなしの伝達-unbiased-transmission.html", "Chapter 2 バイアスなしの伝達 Unbiased transmission 2.1 シミュレーションの初期化 Initialising the simulation 2.2 Execute generation turn-over many times 2.3 モデルの結果をプロットするPlotting the model results 2.4 モデルのコードをラップする関数を書く Write a function to wrap the model code 2.5 Run several independent simulations and plot their results 2.6 初期状態を変えるVarying initial conditions 2.7 モデルのまとめSummary of the model 2.8 Further reading", " Chapter 2 バイアスなしの伝達 Unbiased transmission シンプルなバイアスのない文化伝達のシミュレーションから始めよう。まずはシミュレーションの各ステップを、コードを一行ずつ追っていきながら説明する。最初に書くモデルは次章以降も引き続き使い、少しずつ複雑性を高めていく。 2.1 シミュレーションの初期化 Initialising the simulation ここでは\\(population\\_size\\)2人の個人が二つの独立した文化形質のどちらかひとつだけを有している状況を想定しシミュレートしてみよう。それら2つの形質の選択肢は、\\(A\\)および\\(B\\)としよう。\\(A\\)はたとえばベジタリアンの食事習慣を採用することで、\\(A\\)はノンベジタリアンの食事習慣を採用することだ。現実には、形質というのは明確に二分できるものであることは少ない（たとえば、前記の例であれば、動物の肉は食べないが魚介類は食べるペスカタリアンはこのどちらにも容易に分類できない）。しかし、モデルというものはそういった複雑さを切り捨て、単純化された状況で理解可能な答えを導出するためにデザインするものなのだ。 このモデルでは、世代generationはオーバーラップしない。各世代において、\\(population\\_size\\)人の個人全員が \\(population\\_size\\)人に置き換えられる。これもまた、現実の生物の群れではまずありえない話だが、時系列の変化をシミュレートするうえで有用な単純化ができる。ここでいう世代は生物学的な世代でもよいが、いわば文化的世代（もしくは学習エピソードlearning episodes）のようなずっと短い世代であってもよい。 新世代の新人たちは、前世代の成員からランダムに一人選び、その人の有する文化形質をコピーするとしよう。これはバイアスのない（unbiased）、斜めの(oblique)、文化伝達として知られている。「バイアスのない」とは形質が全くのランダムで決定することからきている。「斜め」とは成員が、前の、しかもオーバーラップしていない世代からコピーすることを意味する。ほかの伝達方法、たとえば水平伝達においては成員は自分と同じ世代から形質をコピーするし、垂直伝達においては子孫が自らの生物学的な親から形質をコピーする。 バイアスのない方法でふたつの文化形質が伝達されると想定すると、集団での形質の頻度にはどのような影響を及ぼすだろうか。この疑問に答えるには、形質\\(A\\)を有する個人の割合の世代ごとの変化を追う必要がある。この割合を\\(proportion\\_of\\_trait\\_a\\)としよう。形質\\(B\\)の割合も追うことはできるのだが、\\(A\\)と\\(B\\)の排他的な関係からこれは常に\\(1 - proportion\\_of\\_trait\\_a\\)となる。たとえば人口の\\(70\\%\\)が形質\\(A\\)を有する場合\\((proportion\\_of\\_trait\\_a=0.7)\\)、残りの\\(30\\%\\)が形質\\(B\\)を有することになる（つまり\\(1-proportion\\_of\\_trait\\_a=1-0.7=0.3\\)）。 このモデルのアウトプットは\\(proportion\\_of\\_trait\\_a\\)の変化を全世代にわたってプロットすることになる。世代(もしくはタイムステップ)は\\(timestep\\)で表す。第1世代は\\(timestep=1\\)、第2世代は\\(timestep=2\\)と続き、合計世代数は\\(timesteps\\)とする。 まずは固定のパラメータを決定しよう。シミュレーション開始前に決定し、シミュレーション実行中に変更しない量だ。このモデルにおいてはpopulation_size（個人の数）とtimestepsだ。population_size = 100とtimesteps = 200ではじめてみよう。 population_size &lt;- 100 timesteps &lt;- 200 つぎに成員をつくろう。個々人について記録すべき唯一の情報は、彼らが有する文化形質(\\(A\\)もしくは\\(B\\))だ。populationを個人の属する集団としよう。populationのデータ構造はベクトルである3。 初期設定として、\\(A\\)か\\(B\\)をランダムに各個人に割り当てよう。sample()という関数が使える。sample()関数には3つの引数（ひきすう。インプット、オプション）がある。詳しくはRStudioのコンソールで?sampleと入力することでヘルプが参照できるが、第一引数はランダムにサンプルする元となる選択肢を格納したベクトルであり、今回の場合であれば形質\\(A\\)と\\(B\\)を文字列（\"A\"と\"B\"）として格納することにしよう。第二引数は何回ランダムにサンプルするかであり、今回の場合であれば一個人につき一つであるから全員分、つまり\\(population\\_size\\)回となる。第三引数replaceは一度選ばれた選択肢をそれ以降も選択肢として残す(TRUE)か否か(FALSE)を指定する。今回の場合であればもしサンプルしたのちにそれ以降選択肢として残さないとなると、一人目に\\(A\\)か\\(B\\)のどちらかを割り振ると、二人目で選択肢はもう片方しか残っておらずすぐに選択肢が尽きることになるため、当然選択肢を再利用する（replace = TRUEを設定する）ことになる。デフォルト値はFALSEであるため、必ず設定しなければならない。 population &lt;- sample(c(&quot;A&quot;, &quot;B&quot;), population_size, replace = TRUE) 変数名をRコンソールに打ち込むことによって簡単に文化形質の状況がわかる： population ## [1] &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; ## [19] &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; ## [37] &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; ## [55] &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; ## [73] &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; ## [91] &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; 想定通り、populationは\\(A\\)と\\(B\\)をランダムに含むベクトルとなっている。 特定の個人の形質はRの大かっこ表記で抽出することができる。たとえば4番目の個人の形質は次のように見ることができる： population[4] ## [1] &quot;B&quot; つぎにシミュレーションのアウトプットを格納するtibbleを用意しよう。tibbleはよりユーザーフレンドリーなdataframeで、tidyverseライブラリに含まれている。アウトプットは各世代での\\(proportion\\_of\\_trait\\_a\\)の推移を記録する。アウトプットのtibbleの大きさは2列\\(timesteps\\)行になる。1世代につき1行で、一列目は世代数（1から\\(timesteps\\)まで）で、アウトプットをプロットする際に役立つ。二列目は各世代での\\(proportion\\_of\\_trait\\_a\\)を格納しよう。 現時点では\\(proportion\\_of\\_trait\\_a\\)が各世代でいくつになるかがわからないので、ひとまずoutputtibbleの当該列にはすべてNAを入れておこう。NAはR言語での「該当なし(Not Available)」、つまり欠測値を意味するシンボルである。NAを\\(timesteps\\)回リピートするにはrep()関数を使う。NAを使い、0を使わないのは、0は\\(proportion\\_of\\_trait\\_a=0\\)であると誤解されかねないからで、それ自体はシミュレーションの結果全個人が形質\\(B\\)を有しているというあり得る結果だからである。現時点では\\(proportion\\_of\\_trait\\_a\\)の値は算出されないので、値は0ではなく「存在しない」のが正しい。さらに、NAでもよいのだが、じつはRのデフォルトのNAはTRUE/FALSEの類の値が入ることを想定しており、ロジカル型(logical type)である。ここには実数(real number)が入るということを考慮に入れ、tidyverseの用意するdouble型のNAであるNA_real_を使ってみよう。 output &lt;- tibble(timestep = 1:timesteps, proportion_of_trait_a = rep(NA_real_, timesteps)) output ## # A tibble: 200 x 2 ## timestep proportion_of_trait_a ## &lt;int&gt; &lt;dbl&gt; ## 1 1 NA ## 2 2 NA ## 3 3 NA ## 4 4 NA ## 5 5 NA ## 6 6 NA ## 7 7 NA ## 8 8 NA ## 9 9 NA ## 10 10 NA ## # … with 190 more rows outputをコンソールに入れてみると、proportion\\_of\\_trait\\_aの列の型がlgl(logical型)ではなくdouble型になっていることがわかる。 NAを入力することには成功したが、考えてみると第1世代の集団の形質は既に生成しているのだから、第1世代のproportion\\_of\\_trait\\_aの値は計算可能のはずだ。以下のコードではpopulationベクトル内の文字列\"A\"の数を数え上げ、population\\_sizeで割ることで割合を計算している。そしてその値をoutputのテーブルのproportion\\_of\\_trait\\_aの列の第一行目（[1]）つまり第1世代\\(timestep=1\\)に代入している。チャンクの2行目ではこれまでと同様、テーブルの変数名を書くことでうまくいっているか確認している。 output$proportion_of_trait_a[1] &lt;- sum(population == &quot;A&quot;) / population_size output ## # A tibble: 200 x 2 ## timestep proportion_of_trait_a ## &lt;int&gt; &lt;dbl&gt; ## 1 1 0.46 ## 2 2 NA ## 3 3 NA ## 4 4 NA ## 5 5 NA ## 6 6 NA ## 7 7 NA ## 8 8 NA ## 9 9 NA ## 10 10 NA ## # … with 190 more rows このproportion\\_of\\_trait\\_aの第1世代の値は\\(0.5\\)前後になっているはずだ。つまり\\(population\\_size=100\\)人のうち50人程度が形質\\(A\\)を有し、残り50人程度が形質\\(B\\)を有しているはずだ。sample()関数はそれぞれの形質を同じ確率で返すはずなのだが、だからといって形質\\(A\\)をちょうど50、形質\\(B\\)をちょうど50返すというわけではない。これは、有限な人口サイズでシミュレーションをする場合にはつきものの現象で、決定論的ではなく確率論的なふるまいだ。コインを100回投げたとしても、常に表が50回でて裏が50回でるわけではないのと同じだ。ときには表が51回、ときには表が49回、などとでるはずだ。上記のsample()関数からこのシミュレーションをやりなおすと、毎回異なるproportion\\_of\\_trait\\_aの値が算出されることでこの現象を確かめられる。 2.2 Execute generation turn-over many times 集団は作れたので、実際に世代を更新していきシミュレーションを回してみよう。処理を\\(timesteps\\)世代ぶん繰り返すことになる。いちどの世代更新で、次の処理をする必要がある： いまのpopulationベクトルは先程までの集団の形質を保存しているため、previous_populationという別のベクトルに保管し、今世代の個人にとってのデモンストレーター4とする。こうすることによってオーバーラップしない、複数世代が混在しない世代間の斜めの伝達が実装できる previous_populationベクトルからランダムに形質を選択した今世代の個人を生成する 今世代のproportion\\_of\\_trait\\_aを計算し、outputの該当するセルに保管する timestepをひとつずつ増やしながらforループで繰り返し計算しよう[Rのforループは遅く、なるべく避けるべきとされているが、IBMの特性からforループを避けて実装することは難しい]。第1世代に関してはここまでのコードで実装されているため、第2世代からはじめる。各行で何をしようとしているかをコメントでかんたんに説明している。現時点の非常にシンプルなコードにはあまりに冗長に思えるかもしれないが、習慣として身につけておくに越したことはない[実装時は隅から隅までわかっていても、数ヶ月後に実際に論文を投稿する際に憶えているとは限らない。]。コードはしばしば他のところにコピペされ、当初の文脈を失う。各行が何をするかをメモしておけば、他のひと（とくに未来の忘れっぽいあなた）に意図を知ってもらえる。 for (timestep in 2:timesteps) { # populationテーブルをprevious_populationという新しいテーブルにコピー previous_population &lt;- population # 前世代の個人からランダムに形質をコピーする population &lt;- sample(previous_population, population_size, replace = TRUE) # proportion_of_trait_aを計算し、outputの今timestep世代のところに格納する output$proportion_of_trait_a[timestep] &lt;- sum(population == &quot;A&quot;) / population_size } 上記のコードチャンクを実行すれば、200世代に渡ってproportion\\_of\\_trait\\_aが計算・記録されているはずだ。outputとタイプすることでそのリストを閲覧することもできるが、その結果をプロット（描画）するほうがずっと効果的だ。 2.3 モデルの結果をプロットするPlotting the model results ggplot()を使ってデータをプロットする。ggplotの構文（シンタックス）はもしかすると少しとっつきにくいかもしれないが、強制的に「プロットに必要なデータはどんな構造になるか」をプロット前に考えさせるように工夫されている。 下記のコードの1行目では、ggplotにプロットしたいデータはoutputtibbleだということを伝えている。それから、aes()関数で見た目aestheticsを宣言する。見た目とはいうが、ここではプロットにおいてデータをどう表示したいかを司る。今回の場合では、proportion\\_of\\_trait\\_aをy軸に、timestepをx軸にしたい（そしてこれがoutputtibbleにおいてtimestepの列を作っておいた理由である）。 2行目でgeom_line()関数を使う。ggplotでは、’geoms’で視覚的な表現法を指定する。線なのか、バーなのか、ボックスなのか、などである。視覚的な表現法は既に宣言したデータのマッピングとは独立である。同じデータを同じマッピングで、異なる視覚的な方法で表現する方法は複数ある。今回は、ggplotにデータを線グラフとして（_line()で）表現するようお願いしている。もし点々の散布図で表現したければ、下記geom_line()をgeom_point()に書き換えて何が起きるか見てみよう。geomsはこれら2つのようにわかりやすいものばかりではない。本書のあとのほうでその一部が登場する。 それ以降のコードは主にプロットの見た目を整えている。y軸の範囲を\\(proportion_of_trait_a\\)が取りうるすべての値の範囲である0から1に拡張し、特定の「テーマ」を使用する。今回はシンプルな白黒のテーマ(theme_bw)を使うことにする。labs()関数によってよりわかりやすい軸名をy軸につけた。ggplotは、自動的にtibbleのプロットに使う列の名前を軸名として使う。x軸のtimestepはそれでも問題ないが、proportion_of_trait_aは変えたほうがいい。 ggplot(data = output, aes(x = timestep, y = proportion_of_trait_a)) + geom_line() + ylim(c(0, 1)) + theme_bw() + ylab(&quot;proportion of individuals with trait A&quot;) Figure 2.1: バイアスなしの文化伝達下での形質Aを有する個人の割合のランダムな変動 形質\\(A\\)を有する個人の割合は0.5付近から始まるはずだ。それからランダムに振動し始めるはずだ（場合によってはすべての\\(A\\)が消失して0になったり、逆にすべての\\(B\\)が消失して1になることもありうる）。バイアスのない伝達、別名ランダムなコピーは定義から言ってランダムであり、シミュレーションの試行runごとに異なるプロットを生成する。上記コードを実行しなおせば、少し違ったプロットになるだろう。何度も走らせていると、ほぼ間違いなくいつかは\\(proportion_of_trait_a\\)が0や1になるだろう。\\(proportion_of_trait_a = 0\\)において\\(A\\)は存在せず全個人が\\(B\\)を有する。\\(proportion_of_trait_a = 0\\)において\\(B\\)は存在せず全個人が\\(A\\)を有する。これは典型的な文化的浮動cultural driftのふるまいだ。文化的浮動は遺伝的浮動genetic driftに類似した現象である。小さな集団において、淘汰やその他の方向性のあるプロセスなしに、しばらく世代が下ったのちに形質が全く偶然に失われてしまうというふるまいである5。 2.4 モデルのコードをラップする関数を書く Write a function to wrap the model code 理想的には、シミュレーションを何度も繰り返し、パラメーターを変更するなどしてモデルをより詳細に理解したい。たとえば、もっと大きい\\(population_size\\)の場合、形質が失われる可能性は増えるのだろうか、減るのだろうか？前述したとおり、このようなインディヴィジュアル・ベースト・モデルは確率的/確率論的であるため、何が起きるかを理解するには何度もシミュレーションを試行する必要がある。今まで書いてきたコードはいくつものチャンクに散乱しており、何度もシミュレーションを走らせるにはむいていない。これから、それらをひとつにまとめあげるラッピングwrapping関数を書こう。 model_unbiased_transmission &lt;- function(population_size, timesteps) { population &lt;- sample(c(&quot;A&quot;, &quot;B&quot;), population_size, replace = TRUE) output &lt;- tibble(timestep = 1:timesteps, proportion_of_trait_a = rep(NA, timesteps)) output$proportion_of_trait_a[1] &lt;- sum(population == &quot;A&quot;) / population_size for (timestep in 2:timesteps) { # Copy individuals to previous_population tibble previous_population &lt;- population # Randomly copy from previous generation population &lt;- sample(previous_population, population_size, replace = TRUE) # Get p and put it into output slot for this generation t output$proportion_of_trait_a[timestep] &lt;- sum(population == &quot;A&quot;) / population_size } # Export data from function output } これは今まで実行してきたコードスニペットをひとつにまとめただけではあるが、2つのパラメーター\\(population_size\\)と\\(timesteps\\)を引数にとるひとつの関数にまとめられている。さらに、model_unbiased_transmission()はoutputという行で終わっている。これはoutputtibbleが返り値として返されるということを意味する。こうすることによって、シミュレーションを走らせたあとにデータを失うことなくデータを保管しておくことができる。 上記のコードを実行しても何も起きない。今の段階では単に上記の関数を定義しただけで、シミュレーションを実際に走らせたわけではないからだ。しかしこれで、一気に関数を実行することができ、簡単に\\(population_size\\)や\\(timesteps\\)といった設定を買えることができる。今までと同じ\\(population_size\\)、同じ\\(timesteps\\)でシミュレーションを走らせ、返り値をdata_unbiased_transmissionに格納してみよう。 data_unbiased_transmission &lt;- model_unbiased_transmission(population_size = 100, timesteps = 200) もうひとつ、プロット用の関数を用意することで、毎回プロットの指令を書き下す手間を省こう。現時点ではあまり実用的でないように思えるかもしれないが、シミュレーションを走らせる関数とその結果をプロットする関数をわけておくことにはいくつかの利点がある。もっと複雑なモデルになってくると、プロットの細部を変更したいからといってシミュレーションを回し直すのは望ましくない。また、モデルの生の返り値と、そのありうる可視化方法や解析方法を明確に分離しておくことは概念的にも意味がある。モデルと同様、以下のコードも既に書いたコードの使いまわしである。 plot_single_run &lt;- function(data) { ggplot(data = data, aes(x = timestep, y = proportion_of_trait_a)) + geom_line() + ylim(c(0, 1)) + theme_bw() + ylab(&quot;proportion of individuals with trait A&quot;) } こうすることで、つぎのように結果を可視化できる。 data_unbiased_transmission |&gt; plot_single_run() Figure 2.2: バイアスなしの文化伝達下での形質Aを有する個人の割合のランダムな変動 ここで、|&gt;はRの4.1.0から実装されたパイプである6。パイプの左側(left hand side, LHS)で生成された返り値を、パイプの右側(right hand side, RHS)に渡し、実行するという機能がある。たとえば上記のコードは以下と同値である7。 plot_single_run(data_unbiased_transmission) 予想されたとおり、コードが全く同一のものであるにも関わらず今回のプロットは前回のプロットとは異なっている。これは本シミュレーションの確率的な性質によるものだ。 つぎに、パラメータを変えてみよう。こんどはシミュレーションの試行とプロットを一気に行ってみる。下記コードでは、ずっと大きな\\(population_size\\)でシミュレーションをもう一度回した上でプロットしている8。 model_unbiased_transmission(population_size = 10000, timesteps = 200) |&gt; plot_single_run() Figure 2.3: 大きな集団サイズにおけるバイアスなしの文化伝達下での形質Aを有する個人の割合のランダムな変動 振動がずっと小さくなっているはずだ。\\(population_size = 10000\\)の集団ではどちらの形質も固定化fixationすることはほとんどない。もう一度コードを実行してみて、\\(population_size\\)が長期的な動態にどのような影響を及ぼすか調べてみよう。 2.5 Run several independent simulations and plot their results このようにシミュレーションをひとつの関数でくるむのはひとつのコマンドで何度でも試行しなおせるため有用だ。しかし、手作業で何度も走らせるのはさすがに面倒だ。たとえば同じパラメータ値で10回試行し、そのうち何回\\(A\\)が固定化し、何回\\(B\\)が固定化するかをみたいとしよう。現状、model_unbiased_transmission()関数を10回走らせ、毎回その記録をどこかに保管しなければならない。自動的に何度もシミュレーションを試行し、それぞれを別の線でひとつのプロットにまとめられないだろうか。さらに、全試行の\\(proportion_of_trait_a\\)の平均値を線として加えられないだろうか。 新しい変数\\(runs\\)を独立した試行回数として導入しよう。全体を新たなforループでくるみ、\\(runs\\)回の試行を繰り返す。model_unbiased_transmission()関数を書き換え、複数回試行を取り扱えるようにし、model_unbiased_transmissions()としよう9。 model_unbiased_transmissions &lt;- function(population_size, timesteps, runs) { output &lt;- tibble(run = factor(), timestep = numeric(), proportion_of_trait_a = numeric()) # 毎回の試行 for (run in 1:runs) { # 1回の試行の結果を保管するtibbleを初期化 output_single_run &lt;- tibble(run = rep(run, timesteps) %&gt;% as.factor(), timestep = 1:timesteps, proportion_of_trait_a = rep(NA, timesteps)) # 第1世代 population &lt;- sample(c(&quot;A&quot;, &quot;B&quot;), population_size, replace = TRUE) # 第1世代のproportion_of_trait_aを計算 proportion_of_trait_a &lt;- sum(population == &quot;A&quot;) / population_size output_single_run$proportion_of_trait_a[1] &lt;- proportion_of_trait_a for (timestep in 2:timesteps) { # 前タイムステップまでのpopulationベクトルをprevious_populationに移し替える previous_population &lt;- population # ランダムに前世代の個人から形質をコピーする population &lt;- sample(previous_population, population_size, replace = TRUE) # proportion_of_trait_aを計算し、tibbleのうちproportion_of_trait_a列のtimestep行目に格納する output_single_run$proportion_of_trait_a[timestep] &lt;- sum(population == &quot;A&quot;) / population_size } # output tibbleの一番下に今回の試行の結果をbind_rows()関数で付け加える output &lt;- bind_rows(output, output_single_run) } # 全試行の結果がひとつのoutputというtibbleに集約されたので、それを返り値としてエクスポートする output } ここでいくつかの変更を加えている。まず、outputtibbleには全試行のデータを格納できるようにしなければならない。そのため、従前と同様timestepとproportion_of_trait_aを保管するのに加え、何回目の試行であるかを示す列runを追加した10。まずはoutputtibbleには１行も追加せず、型だけ指定してみよう。列の中身をnumeric()としておくことで連続値のみで構成される行であると、またfactor()としておくことでfactor型（カテゴリカルな値）のみで構成される行であると指定できる。そしてそれぞれの試行において、timestepの更新のたびに結果をoutput_single_run tibbleに格納していく（１試行につきひとつのoutput_single_runを使い回す）。そして試行がおわるたびにbind_rows()関数で結果をoutputtibbleの下部に付け加えていく[bind_rows()関数の使い方に関しては tidyverse のマニュアルを参照。]。runはas.factor()関数にパイプでつなぎ、factor型、つまりカテゴリカル変数として記録している。これは、runを1,2,3という数字で記録しても、何番目の試行であるというだけの理由でつけられた便宜上のラベルであり、3番目の試行が6番目の試行にくらべて半分しか「試行」でない、ということはありえず、連続値の実数として捉えられるべきではないからだ。試行は文字やその他どんな方法でラベル付けしてもいいたぐいのものである。as.factor()を除いてもシミュレーションの実行そのものにはなんの差もうまないが、データをプロットする段になって問題が起きる。というのも、ggplotが試行を離散のカテゴリとしてではなく連続の実数として扱うためだ（この差は上記コードでfactor()をnumeric()にしたうえで%&gt;% as.factor()を削除することで確認できる）。に必要なデータの構造をプロットや解析をするまえに考えることの重要性を示すよい例である[と原著では書いているが、factor型への変更などはシミュレーションをまわしたあとでもごく簡単に(data %&gt;% mutate(run = as.factor(run))とするか、geom_line(aes(group = as.factor(run)))できるし、連続値として保存しておくことの利点も大きい。まずは連続値として保管しておき、プロットの段になってデータを微調整する、というワークフローのほうが現実的には有用だと私は思う。]。 関数に戻ろう。各試行１度だけまわるループを設定した。ループ内部のコードは今までとほぼ全く一緒だ11。 プロットする関数も、複数の試行に対応できるよう書き換える： plot_multiple_runs &lt;- function(data) { ggplot(data = data, aes(x = timestep, y = proportion_of_trait_a)) + geom_line(aes(colour = run)) + stat_summary(fun = mean, geom = &quot;line&quot;, size = 1) + ylim(c(0, 1)) + theme_bw() + ylab(&quot;proportion of individuals with trait A&quot;) } 上記コードがどう動くかを理解するには、ggplotの一般的な機能の仕方を説明する必要がある。前述したとおり、aes()はaesthetics、つまりデータがどうプロットにマップされるかを設定する。これはマッピングの視覚的な表現、つまり’geoms’とは独立である。ggplot()関数を呼び出したときに特定のaestheticsを宣言したら、そのaestheticsはそれ以降のgeomsすべてに適用される。しかし、geomごとにaestheticsを指定することもできる。例えば次のように： output |&gt; ggplot(aes(x = timestep, y = proportion_of_trait_a)) + geom_line() 上記は下記と同等である： output |&gt; ggplot() + geom_line(aes(x = timestep, y = proportion_of_trait_a)) この性質を使うと、もっと複雑なプロットを構築することができる。plot_multiple_runs()で最初に登場するgeomであるgeom_line()を考えよう。geom_line()は最初に呼び出したggplot()で設定したaestheticsを継承するが、加えてgeom_line()特有の新しいマッピングcolour = runを指定している。これにより、各試行のラインを違う色で塗るようにggplotに伝えているのだ。次のgeomのstat_summary()はすべての試行について平均を計算する12。しかし、マッピングに関しては最初のggplot()の呼び出しのものしか継承しない。もしstat_summary()内でaestheticをcolour = runと指定すれば、データをrunでわけ、それぞれの試行ごとに平均を計算するだろう。しかし、その平均の線はさきほどgeom_line()でプロットしたものと全くおなじになる。それゆえ、colour = runをggplot()関数の中では指定せず、色を分けたいgeom_line()でのみ指定するようにしている。よくあることだが、同じ結果をいくつもの方法で実装できる。以下のコードは： output |&gt; ggplot(data = output) + geom_line(aes(x = timestep, y = proportion_of_trait_a, colour = run)) + stat_summary(aes(x = timestep, y = proportion_of_trait_a), fun = mean, geom = &quot;line&quot;, size = 1) 上記の関数として書いたものと同等である。しかし、元のコードのほうがグローバルマッピングと各視覚的な表現で用いる特定のマッピングをはっきりとわけて書いており、より明快である。 stat_summary()はggplotのジェネリックな関数で、データをなんらかの統計量に要約summarizeする際に使える。今回は、\\(y\\)にマップされたデータを平均し、折れ線として描画し、ほかの試行結果のプロット線よりも太く描画したい。デフォルトの線幅は0.5のため、size = 1と設定するとデフォルト値の倍の太さになる。 つぎに関数を実行し、最初に用いたのと同じパラメーター（\\(population_size = 100\\)、\\(timesteps = 200\\)）で5試行まわした結果をプロットしてみよう。 data &lt;- model_unbiased_transmissions(population_size = 100, timesteps = 200, runs = 5) plot_multiple_runs(data) Figure 2.4: バイアスなしの文化伝達が複数回試行すると異なった動態を示す 5回の独立した試行が通常の細めの線で、その平均が太めの線で描画されているはずだ。試行によっては0か1に達しているものもあり、平均はおそらくその間を行き来しているだろう。データはdataに保存されており、データの変数名を打ち込めばテーブルとして確認することができる。 data ## # A tibble: 1,000 x 3 ## run timestep proportion_of_trait_a ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 0.48 ## 2 1 2 0.53 ## 3 1 3 0.5 ## 4 1 4 0.46 ## 5 1 5 0.46 ## 6 1 6 0.36 ## 7 1 7 0.29 ## 8 1 8 0.4 ## 9 1 9 0.41 ## 10 1 10 0.47 ## # … with 990 more rows 今度はmodel_unbiased_transmissionsの\\(population_size\\)を10000に設定し、\\(population_size = 100\\)と比較してみよう。 data &lt;- model_unbiased_transmissions(population_size = 10000, timesteps = 200, runs = 5) plot_multiple_runs(data) Figure 2.5: バイアスなしの文化伝達は集団サイズが極めて大きいと、異なる試行間でも似たようなダイナミクスを示す 平均を示す線は今回ほぼ完全に\\(proportion_of_trait_a = 0.5\\)になったはずで、５回の独立した試行の線もかなりそれに近いはずだ。 2.6 初期状態を変えるVarying initial conditions 最後の変更を加えよう。いまのところ、\\(A\\)と\\(B\\)のスタート時の頻度はずっと同じで、だいたい0.5ずつになっている。もし\\(A\\)と\\(B\\)の初期頻度が違ったらどうなるだろう、たとえば\\(proportion_of_trait_a = 0.2\\)とか\\(proportion_of_trait_a = 0.9\\)ではじまったら？バイアスなしの伝達は\\(proportion_of_trait_a\\)を初期頻度と同じに保つだろうか、それとも今までと同様に\\(proportion_of_trait_a = 0.5\\)に落ち着くのだろうか？ To find out, we can add another parameter, p_0, which specifies the initial probability of an individual having an \\(A\\) rather than a \\(B\\) in the first generation. Previously this was always p_0 = 0.5, but in the new function below we add it to the sample() function to weight the initial allocation of traits. これに答えるために、もう一つのパラメータ\\(initial\\_proportion\\_of\\_trait\\_a\\)13を加えよう。この新パラメータは第1世代の個々人が\\(B\\)ではなく\\(A\\)を有する初期の確率を設定する。いままではつねに\\(initial_proportion_of_trait_a = 0.5\\)ではじめていたが、次の新しい関数ではsample()関数において最初の形質配分を\\(initial\\_proportion\\_of\\_trait\\_a\\)を用いて制御する。 model_unbiased_transmissions_varying_initial_condition &lt;- function( population_size, timesteps, runs, initial_proportion_of_trait_a) { output &lt;- tibble( run = numeric(), timestep = numeric(), proportion_of_trait_a = numeric() ) for (run in 1:runs) { # 1回の試行の結果を保管するtibbleを初期化 output_single_run &lt;- tibble(run = rep(run, timesteps), timestep = 1:timesteps, proportion_of_trait_a = rep(NA, timesteps)) # 第1世代 population &lt;- sample(c(&quot;A&quot;, &quot;B&quot;), population_size, replace = TRUE, prob = c(initial_proportion_of_trait_a, 1 - initial_proportion_of_trait_a)) # 第1世代のproportion_of_trait_aを計算 proportion_of_trait_a &lt;- sum(population == &quot;A&quot;) / population_size output_single_run$proportion_of_trait_a[1] &lt;- proportion_of_trait_a for (timestep in 2:timesteps) { # 前タイムステップまでのpopulationベクトルをprevious_populationに移し替える previous_population &lt;- population # ランダムに前世代の個人から形質をコピーする population &lt;- sample(previous_population, population_size, replace = TRUE) # proportion_of_trait_aを計算し、tibbleのうちproportion_of_trait_a列のtimestep行目に格納する output_single_run$proportion_of_trait_a[timestep] &lt;- sum(population == &quot;A&quot;) / population_size } # output tibbleの一番下に今回の試行の結果をbind_rows()関数で付け加える output &lt;- bind_rows(output, output_single_run) } # 全試行の結果がひとつのoutputというtibbleに集約されたので、それを返り値としてエクスポートする output } model_unbiased_transmissions_varying_initial_condition()は以前の関数とほぼ同一だが、引数\\(initial\\_proportion\\_of\\_trait\\_a\\)を追加し、sample()関数においてprob引数を設定している。ここでのprob引数はそれぞれのオプション（この場合\\(A\\)と\\(B\\)）を第1世代として選ぶ確率を設定する。\\(A\\)になる確率はいま\\(initial\\_proportion\\_of\\_trait\\_a\\)であり、\\(B\\)になる確率はいま\\(1 - initial_proportion_of_trait_a\\)となる。プロットにはいままでと同じものを使える。\\(initial\\_proportion\\_of\\_trait\\_a\\)を、たとえば0.2に変えると何が起きるかを見てみよう。 model_unbiased_transmissions_varying_initial_condition( population_size = 10000, initial_proportion_of_trait_a = 0.2, timesteps = 200, runs = 5) |&gt; plot_multiple_runs() Figure 2.6: ランダムな変動はあるものの、バイアスなしの伝達は初期状態から形質頻度を変えることはない \\(initial_proportion_of_trait_a = 0.2\\)において、形質の頻度は\\(proportion_of_trait_a = 0.2\\)から変わることはない。バイアスなしの伝達は真に方向性を持たない。つまり、集団サイズの小ささからくるランダムな変動はあるものの、前世代の形質の頻度（それがいくつであれ）を維持しようとする。 2.7 モデルのまとめSummary of the model このような極端に単純なモデルでも、有用な洞察を提供してくれる。第一に、バイアスなしの伝達はそれ自体が形質の頻度を変えることはない。集団サイズが大きい限り、形質頻度は同程度にとどまる。 第二に、集団サイズが小さければ小さいほど、形質は偶然に失われやすくなる。これは集団遺伝学における基礎的な知見である遺伝的浮動だが、文化進化にも適用できる考えだ。じっさい、集団サイズやその他の人口学的要因が文化の多様性を形作るのではないかという疑問はいくつもの研究で検証され（、そしていくつかは実証され）ている。 更に、文化的変化がランダムな文化的浮動によって引き起こされているという予想をもっておくことは、淘汰圧のような非ランダムな傾向を検出する際に有用である。基準となるものがなければ、淘汰圧やその他の方向性のあるプロセスに出会ったとしても、そうであると気付けないからだ。 We have also introduced several programming techniques that will be useful in later simulations. We have seen how to use tibbles to hold characteristics of individuals and the outputs of simulations, how to use loops to cycle through generations and simulation runs, how to use sample() to pick randomly from sets of elements, how to wrap simulations in functions to easily re-run them with different parameter values, and how to use ggplot() to plot the results of simulations. 以降のシミュレーションを構築するにあたって有用ないくつかのプログラミング上のテクニックも紹介した。tibbleをつかって個人の特徴やシミュレーションの返り値を保管したり、ループで世代や試行を繰り返したり、sample()関数で要素の集合からランダムに抽出したり、シミュレーション全体を関数としてラップすることで違うパラメータ値で何度も実行したり、ggplot()関数でシミュレーション結果をプロットしたりした。 2.8 Further reading Cavalli-Sforza and Feldman (1981) explored how cultural \\(population\\_size\\)は、原著では\\(N\\)であった。序章で述べたように、日本語版ではコード中での可読性を優先し、一文字の変数名は避け、意味のわかる変数名を採用している。↩︎ 訳註：原著ではtidyverseのtibbleを採用していたが、この時点では1列しかないため、日本語版ではより計算量が少なくてすむベクトルを採用している。ベンチマークしてみると、およそ2倍の速度で計算される。↩︎ 形質をコピーしてくる源となる、いわば先輩たち↩︎ 浮動によってある形質が全く失われてしまうということはあるが、浮動があれば形質が失われるという意味ではない↩︎ 類似の機能を提供するものにmagrittrライブラリの提供するパイプ%&gt;%が有名である。|&gt;のほうが動作が速いと言われている↩︎ 原著ではこのようにプロットしているが、日本語版ではパイプの使用がむしろコードの可読性を高めるという立場からパイプをしばしば使っている↩︎ 前述の「シミュレーションの結果とプロットの関数をわけるべき」という原則に反するが、シミュレーションからプロットまで一気通貫に1アクションで行えるパイプの魅力に勝るものはない↩︎ 原著ではunbiased_transmission_2()。↩︎ 原著では最初に最終的なアウトプットと同サイズの巨大なtibbleをつくり、NAを入れるなどして初期化している。本バージョンでは型だけ指定した0行３列のtibbleの殻を用意し、試行が終了するたびに行を一気に追加するようにしている。この変更と今までの高速化により、筆者の環境で7.5倍程度高速化している↩︎ 原著では\\(proportion_of_trait_a\\)の保管位置を工夫する必要がでているが、bind_rows()を使う本コードではそこに思い悩む必要はない。↩︎ colour = runのaestheticsをggplot()の中で設定するとすべての試行についての平均にはならない。わざわざ色の情報をgeom_line()に書いているのは、stat_summary()では試行ごとでグルーピングしたくないから。↩︎ 原著では\\(p_0\\)↩︎ "]]
